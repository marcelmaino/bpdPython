# Plano de Desenvolvimento Detalhado: Dashboard de Poker

**Projeto:** Sistema de Dashboard para Controle de Efici√™ncia e Gest√£o Financeira de Poker
**Data do Plano:** 11 de julho de 2025
**Tecnologias Principais:** Python (Streamlit), MySQL, Tailwind CSS v4 (via inje√ß√£o de CSS)

---

## Fase 0: Configura√ß√£o do Ambiente e Estrutura do Projeto

**Objetivo:** Preparar todo o ambiente de desenvolvimento, estabelecer a conex√£o com o banco de dados e criar a estrutura de arquivos inicial.

1.  **Estrutura de Diret√≥rios:**
    *   Criar o diret√≥rio raiz do projeto.
    *   Dentro dele, criar os seguintes arquivos e pastas:
        *   `app.py`: Arquivo principal da aplica√ß√£o Streamlit.
        *   `requirements.txt`: Lista de depend√™ncias Python.
        *   `database.py`: M√≥dulo para gerenciar a conex√£o e as queries ao banco de dados.
        *   `auth.py`: M√≥dulo para gerenciar a autentica√ß√£o e os dados dos usu√°rios.
        *   `utils.py`: Fun√ß√µes de utilidade (c√°lculo de datas, formata√ß√£o, etc.).
        *   `.streamlit/`: Pasta de configura√ß√£o do Streamlit.
            *   `secrets.toml`: Arquivo para armazenar as credenciais do banco de dados de forma segura.
            *   `config.toml`: (Opcional) Para configura√ß√µes gerais do Streamlit.

2.  **Ambiente Virtual:**
    *   Criar e ativar um ambiente virtual Python para isolar as depend√™ncias do projeto.
    *   Comando: `python -m venv venv` e `source venv/bin/activate` (ou `venv\Scripts\activate` no Windows).

3.  **Instala√ß√£o de Depend√™ncias:**
    *   Criar o arquivo `requirements.txt` com o seguinte conte√∫do:
        ```
        streamlit
        mysql-connector-python
        pandas
        numpy
        ```
    *   Instalar as depend√™ncias: `pip install -r requirements.txt`.

4.  **Configura√ß√£o de Credenciais (`secrets.toml`):**
    *   Criar o arquivo `.streamlit/secrets.toml` com as informa√ß√µes de acesso ao MySQL para que o Streamlit possa se conectar de forma segura.
        ```toml
        [mysql]
        host = "mysql465.umbler.com"
        user = "bpd"
        password = "WC.3cK7|tk)Ri"
        database = "bpd"
        port = 41890
        ```

---

## Fase 1: Camada de Dados e Backend Core

**Objetivo:** Estabelecer a comunica√ß√£o com o banco de dados e criar as fun√ß√µes para carregar e processar os dados brutos.

1.  **M√≥dulo `database.py`:**
    *   Criar uma fun√ß√£o `get_db_connection()` que l√™ as credenciais do `st.secrets` e retorna um objeto de conex√£o MySQL.
    *   Criar uma fun√ß√£o `load_data()` que:
        *   Estabelece a conex√£o usando `get_db_connection()`.
        *   Executa a query `SELECT * FROM bpd;`.
        *   **Aten√ß√£o:** As colunas com espa√ßos nos nomes (`' dia'`, `' playerName'`, etc.) devem ser tratadas corretamente, possivelmente envolvendo-as em crases (`) na query SQL.
        *   Carrega os dados em um DataFrame Pandas.
        *   Realiza uma limpeza inicial:
            *   Converte a coluna `' dia'` para o formato datetime.
            *   Remove espa√ßos em branco dos nomes das colunas do DataFrame para facilitar a manipula√ß√£o (`df.columns = df.columns.str.strip()`).
        *   Retorna o DataFrame limpo.
    *   Implementar cache (`@st.cache_data`) na fun√ß√£o `load_data()` para evitar m√∫ltiplas leituras do banco de dados a cada intera√ß√£o no frontend.

---

## Fase 2: Autentica√ß√£o e Gest√£o de Usu√°rios

**Objetivo:** Implementar o sistema de login para os dois tipos de usu√°rios (Admin e Jogador).

1.  **M√≥dulo `auth.py`:**
    *   Criar uma fun√ß√£o `generate_users(df)` que recebe o DataFrame principal.
    *   A fun√ß√£o ir√°:
        *   Extrair uma lista de jogadores √∫nicos da coluna `playerName`.
        *   Para cada jogador, gerar a senha padr√£o conforme a regra: `Primeira letra do nome em mai√∫scula + "2025" + √∫ltimos 4 caracteres do "playerName"`.
        *   Armazenar isso em um dicion√°rio ou DataFrame de usu√°rios: `{'username': '...', 'password': '...', 'role': 'Jogador'}`.
        *   Adicionar o usu√°rio Admin est√°tico: `{'username': 'admin', 'password': 'adm123456', 'role': 'Admin'}`.
        *   **Nota de Seguran√ßa:** Em um ambiente de produ√ß√£o, as senhas devem ser "hasheadas" (ex: com a biblioteca `bcrypt`). Para este projeto, seguiremos a regra de texto plano conforme solicitado.
    *   Criar uma fun√ß√£o `verify_login(username, password, users_df)` que checa se as credenciais s√£o v√°lidas.

2.  **Integra√ß√£o em `app.py`:**
    *   Utilizar o `st.session_state` para gerenciar o estado de login do usu√°rio (`st.session_state['logged_in']`, `st.session_state['user_role']`, `st.session_state['username']`).
    *   Na inicializa√ß√£o, se o usu√°rio n√£o estiver logado, exibir uma tela de login com campos para usu√°rio e senha (`st.text_input`, `st.text_input(type="password")`).
    *   Ao clicar no bot√£o "Login", chamar a fun√ß√£o `verify_login`. Se for bem-sucedido, atualizar o `st.session_state` e recarregar a p√°gina para exibir o dashboard.

---

## Fase 3: Layout do Frontend e Componentes Est√°ticos

**Objetivo:** Construir a estrutura visual do dashboard, incluindo o menu lateral, header e placeholders para os componentes din√¢micos.

1.  **Configura√ß√£o do Estilo (Tailwind/CSS):**
    *   Em `app.py`, usar `st.set_page_config(layout="wide")` para ocupar a tela toda.
    *   Injetar o CSS para o background:
        ```python
        st.markdown('<style>body { background-color: #f5f7fa; }</style>', unsafe_allow_html=True)
        ```
    *   Para o menu lateral customizado, ser√° necess√°rio injetar um bloco de CSS/HTML mais complexo via `st.markdown` para controlar a largura e a transi√ß√£o. Isso pode ser desafiador, pois o Streamlit n√£o foi projetado para esse n√≠vel de customiza√ß√£o do sidebar. Uma alternativa mais simples seria usar √≠cones diretamente no menu padr√£o do Streamlit.
        *   **Plano A (Complexo):** Usar HTML/CSS injetado para criar um menu lateral do zero.
        *   **Plano B (Simples):** Usar `st.sidebar` e adicionar √≠cones aos links. Ex: `st.sidebar.page_link("app.py", label="üìä Dashboard")`.

2.  **Header:**
    *   Usar `st.columns` para organizar os elementos do header.
    *   **Seletor de Datas:** Implementar os widgets `st.date_input` para o intervalo personalizado e `st.selectbox` ou `st.radio` para as op√ß√µes pr√©-definidas ("Hoje", "Semana Atual", etc.).
    *   **Seletor de Moeda:** Usar `st.toggle` ou `st.radio` para as op√ß√µes de moeda.
    *   **Info do Usu√°rio:** Exibir o `st.session_state['username']` e um bot√£o de "Logout" que limpa a sess√£o.

3.  **Layout Principal:**
    *   Usar `st.columns(5)` para criar os 5 cards de m√©tricas. Usar `st.metric` para exibir os valores. Inicialmente, preencher com valores est√°ticos.
    *   Usar `st.expander("Filtros")` para a se√ß√£o de filtros que pode ser recolhida.
    *   Dentro do expander, adicionar os widgets de filtro: `st.text_input` para a busca global e `st.multiselect` para Clubes e Agentes. Adicionar um `st.button("Limpar Filtros")`.

---

## Fase 4: Componentes Din√¢micos e Interatividade

**Objetivo:** Conectar os dados do backend aos componentes do frontend, tornando o dashboard totalmente funcional.

1.  **Filtragem de Dados:**
    *   Criar uma fun√ß√£o `filter_dataframe(df)` em `app.py` que aplica todos os filtros ativos (data, moeda, busca, clube, agente) ao DataFrame principal.
    *   O DataFrame filtrado ser√° a fonte de dados para todos os elementos visuais.
    *   **L√≥gica do Filtro de Data:**
        *   Em `utils.py`, criar fun√ß√µes para calcular os intervalos de data ("Semana Atual", "√öltima Semana"). Lembrar que a semana come√ßa na Segunda-feira.
    *   **L√≥gica do Filtro de Usu√°rio:** Se o `st.session_state['user_role']` for "Jogador", aplicar um filtro inicial e permanente no DataFrame para mostrar apenas os dados de `playerName == st.session_state['username']`.

2.  **Atualiza√ß√£o dos Cards:**
    *   Calcular os valores para os 5 cards de m√©tricas a partir do DataFrame *filtrado*.
    *   **Total de M√£os:** `filtered_df['hands'].sum()`
    *   **Ganhos/Taxas/Rakeback:** Somar as colunas `real...` ou `dolar...` com base no seletor de moeda.
    *   **Balan√ßo Final:** `Ganhos - Taxas + Rakeback`.
    *   Usar a l√≥gica de cores (verde/vermelho) para o balan√ßo.

3.  **Tabela de Registros:**
    *   Exibir o DataFrame filtrado usando `st.dataframe`.
    *   Configurar as colunas para formata√ß√£o de moeda, datas, etc., usando o `column_config` do `st.dataframe`.
    *   Esconder a coluna `linha_id`.
    *   **Lazy Loading/Pagina√ß√£o:** Para otimizar a performance, implementar um sistema de pagina√ß√£o manual. Adicionar widgets (`st.number_input`, `st.button`) para o usu√°rio selecionar a p√°gina, e ent√£o usar `LIMIT` e `OFFSET` na query SQL ou fatiar o DataFrame Pandas para exibir apenas um subconjunto dos dados por vez.

---

## Fase 5: Funcionalidades Avan√ßadas

**Objetivo:** Implementar a an√°lise de performance por "IA" e refinar a tabela de dados.

1.  **Card de An√°lise por IA:**
    *   Criar um m√≥dulo `insights.py`.
    *   Criar uma fun√ß√£o `generate_insights(df)` que recebe o DataFrame do usu√°rio.
    *   Implementar l√≥gicas de an√°lise simples com Pandas:
        *   `df.groupby('club')['realWins'].sum().idxmax()` para encontrar o melhor clube.
        *   `df.groupby(df['dia'].dt.day_name())['realWins'].sum().idxmax()` para o melhor dia da semana.
        *   Calcular a varia√ß√£o percentual de ganhos em rela√ß√£o a um per√≠odo anterior.
    *   Formatar essas descobertas em frases amig√°veis e exibi-las em um `st.container` com um √≠cone.

---

## Fase 6: Responsividade e Polimento Final

**Objetivo:** Garantir que o dashboard seja funcional e visualmente agrad√°vel em diferentes tamanhos de tela.

1.  **CSS com Media Queries:**
    *   Injetar um bloco `<style>` com media queries para ajustar o layout.
    *   **Tablet:** Mudar o grid dos cards para 2x2.
    *   **Mobile:** Fazer os cards e filtros ocuparem 100% da largura e serem exibidos em uma √∫nica coluna. O menu lateral do Streamlit j√° √© responsivo por padr√£o (vira um menu hamb√∫rguer).

2.  **Polimento da UI:**
    *   Revisar todos os textos, placeholders e √≠cones.
    *   Garantir que a experi√™ncia do usu√°rio seja fluida e intuitiva.
    *   Verificar a consist√™ncia das cores e do estilo.

---

## Fase 7: Testes e Otimiza√ß√£o

**Objetivo:** Assegurar a qualidade, performance e aus√™ncia de bugs na aplica√ß√£o.

1.  **Testes Manuais:**
    *   Navegar pela aplica√ß√£o com o perfil de Admin e de Jogador.
    *   Verificar se o jogador s√≥ v√™ seus pr√≥prios dados.
    *   Testar todas as combina√ß√µes de filtros (datas, moedas, clubes, agentes, busca).
    *   Validar os c√°lculos dos cards de m√©trica com uma amostra de dados.
    *   Testar a funcionalidade de "Limpar Filtros".
    *   Verificar o login e logout.

2.  **Otimiza√ß√£o:**
    *   Confirmar que o `@st.cache_data` est√° funcionando para evitar recargas desnecess√°rias do banco de dados.
    *   Analisar a performance da pagina√ß√£o da tabela com um grande volume de dados.
    *   Minimizar o n√∫mero de rec√°lculos feitos a cada intera√ß√£o.
